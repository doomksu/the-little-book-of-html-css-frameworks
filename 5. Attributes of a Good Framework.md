#Критерии хорошего фреймворка

Теперь о том что такое “хороший” фреймворк. Что именно в фреймворке мы хотим использовать? На чем основывается фреймворк который мы хотели бы написать? Много раз я обсуждал эти вопросы и участвовал в подобных спорах. В профессиональном контексте слово «хороший» обычно означает качество. Мы также можем применить его и в случае фреймворка. Любой фреймворки, особенно это касается внешних, должен соответствовать наиболее высоким, применимым к нему стандартам качества.
Как правило, фреймворки применяются уже после того, как проект разрастается до определенных размеров и сложности (одностраничные сайты не нуждаются в Bootstrap или YAML), и зачастую дополняются сторонними решениями. Поскольку размер и сложность делают проблему тяжелее (и сторонние решения, как мы уже знаем не могут учитывать всех потребностей проекта), нам нужны некоторые гарантии и обеспечение безопасности.
Мы можем получить такие гарантии, если сможем избежать чрезмерного разрастания к которому склонны внешние фреймворки, и мы знаем что тут поможет - специализированность. И так: хороший фреймворк должен быть специализированным.
Рассматривая большие проекты, когда мы обычно не единственные кто работает с фреймворком или разрабатывает его, особенно если это внешний фреймворк, мы не можем быть уверены что разработчики фреймворка вообще говорят на нашем языке (как в прямом так и в переносном смысле). Здесь помогает удобство и простота использования. Хороший фреймворк должен быть практичен.
Ко всему прочему требования могу измениться в любой момент: как мы в дальнейшем сможем работать с фреймворком? Что если нам необходимо добавить что-нибудь. В этом случае помогает расширяемость. И так, фреймворк должен быть еще и расширяемым. По крайней мере мы должны знать, или фреймворк сам должен описывать как можно расширить его.
В начале исходя из соображений профессионализма и разумности мы потребовали качество. Затем мы утвердились в желании получить фреймворк  который так же был бы: специализированным, практичным и расширяемым. Давайте рассмотрим эти три критерия подробнее и выясним что нужно разработчикам что бы привести фреймворк к соответствующему состоянию.

####Что касается качества

Достаточно просто сказать «качество»,и я тоже так делаю, но что же такое качество на самом деле? Или же, говоря о нашей работе, что такое качество кода? Когда мы думаем об этом, не глядя на эти станицы, мы без труда найдем больше чем просто определения специализированности, практичности и расширяемости. Так же есть:

*Скорость
*Доступность
*Семантичность
*Добротность
*Масштабируемость
*Наличие Документации
*Поддержка
*Валидность
*Понятность
*Последовательность
*«Автовыполение»
*Современность
*Простота
*Компактность
*Гибкость
*Наличие тестов
*Отказоустойчивость
*Автокоррекция
*и многое другое

Даже если не учитывать каких то эмоциональных критериев типа «удовольствие» или «радость» от кода, мы можем убедится что понятие качество очень многогранно.

##1.Фреймворк должен быть специализирован

Мы определили специализированность как «производство и регулирование под установленные критерии и потребности». Производство здесь означает разработку внешнего или внутреннего фреймворка, а регулирование обычно означает настройку внешнего фреймворка. Основной вопрос здесь в «установленные критерии и потребности» - мы должны осознавать свои потребности иначе мы не сможем ни производить ни настраивать что-либо.

Одно из представлений о специализированности кода сравнивает необходимый код со всем остальным кодом. Это не просто измерить, потому что количество строк и символов здесь не играет основной роли, но основная идея специализированности кода состоит в том что бы использовать ровно столько кода, сколько необходимо и не более того.
Как мы можем обеспечить специализированность фреймворка? Подход к решению этого вопроса зависит от типа фреймворка.

Внутренний фреймворк сравнительно проще специализировать, в случае с ним мы изначально ведем разработку для потребностей нашего проекта. Потребности эти могут быть определены в виде макетов и мокапов а в лучшем случае  - руководства стиля. После того как определены все типы страниц и элементов, их вносят в код. Если все они используются в приложении или сайте то код однозначно является специализированным (помимо этого он может быть еще оптимизирован и сжат). 

Значительно труднее специализировать внешний фреймворк (здесь имеется в виду сторона принимающая фреймворк, потом что для его автора это и вовсе невозможно). На первый взгляд мы должны отделить весь необходимый нам код и удалить весь остальной. Но тут возникает основная проблема с внешними фреймворками – не всегда возможно такое удаление кода, и тогда специализированность фреймворка зависит от качества его кода и документации (так же специализация может нарушить работу фреймворка, требует тестирования и возможно приведет к необходимости повторять всю эту работу при дальнейших обновлениях фреймворка).
В этом состоит причина по которой некоторые люди углубляются в кастомизацию или специализацию внешних фреймворков (или любого другого стороннего кода). Пока вывод таков – не специализированный и низкокачественный код не профессионален и неквалифицирован. Теперь мы ясно видим почему с профессиональной точки зрения не следует отдавать предпочтение внешним фреймворкам. Они предлагают снизить стоимость, но приносят скрытые издержки или снижают качество нашей работы.

Сейчас некоторые фреймворки, такие как Bootstrap и Gumby начинают решать эти проблемы, предоставляя продвинутые мастера настройки. Это хорошо, так как существенно облегчает проблему не специализированных решений. Разработчикам фреймворков стоит создавать подобные решения, а пользователям применять их.

Кстати есть и еще одна проблема: в то время как нам выгодны и уменьшение издержек и повышение качества, наши конечные пользователи получают побльше пользы от качества. Проше говоря, пользователи вряд ли получат пользу. если мы решим развернуть фреймворк, который будет чрезмерно раздут, но зато легок в создании.
Что бы специализировать внутренний фреймворк:

*Осознайте потребности
*Создайте фреймворк под эти потребности

Что бы специализировать внешний фреймворк:

*Осознайте потребности
*Настройте или измените фреймворк под эти потребности (или же воздержитесь от его использования)

##2.Фреймворк должен быть практичен

Хороший фреймворк не только специализирован, но и практичен. Но что значит практичность фреймворка? Ответ на этот вопрос начинается с распространенного определения практичности: простота в использовании и изучении, а так же универсального правила :«делай это проще», так как простота полезна во всем. Но это не полный ответ, а потому мы снова должны вводить разделение. Отличие тут не между фреймворками, но между ролями: пользователя и разработчика фреймворка.

Для пользователя фреймворка (который может быть так же и разработчиком но рассматривается сейчас как пользователь), практичный фреймворк так же должен быт прост в понимании. Такая простота понимания, достигается путем понятной документации и лаконичности кода.
Для разработчика фреймворка значительно упор делается на удобство кода. К счастью есть две вещи которые мы можем применить что бы сделать код удобнее: [общепринятые практики поддержки](http://bit.ly/meiert-maintGuide) и практики написания кода (руководство кодирования). Приверженность практикам поддержки и согласованному стилю кода является основой практичного кода.

С меньшими ограничениями нежели [developer experience](http://developerexperience.org) я в целом верю в существование такого вида практичности, как практичность для разработчика. Это можно было бы описать как «простой в применении и изучении код». Возможно такой подход заслуживает меньше внимания, поскольку удобство кода, как мы уже выяснил имеет множество названий, но возможно было бы полезно  рассматривать их по отдельности.

Что бы сделать фреймворк практичнее для пользователей:

*Делай это проще.
*Следуйте общепринятым практикам.
*Проведите тестирование удобства использования.
*Предоставьте документацию для пользователей фреймворка.

Что бы сделать фреймворк практичнее для разработчиков:

*Делай это проще.
*Старайтесь создавать понятный код.
*Форматирование кода должно быть последовательным и понятным.
*Следуйте общепринятым практикам поддержки.
*Предоставьте документацию для разработчиков фреймворка.

##3.Фреймворк должен быть расширяемым

Последним критерием который мы рассмотрим будет расширяемость. Расширяемость фреймворка значит не только возможность, но и хорошее описание того как его можно расширить.
Расширяемость важна по двум причинам. Во первых внешние фреймворки обычно, не предоставляют всей необходимой функциональности, поэтому должен быть способ обеспечить ее добавление. Во вторых? Особенно это касается крупных проектов, существует тенденция к появлению новых шаблонов, проблема в том что они непредсказуемы и уникальны. Возможны эти шаблоны будут использованы один-два раза и скорее всего не попадут в ядро фреймворка или даже в ближайшие расширения. Необходимо обдумать и расположение и применение таких шаблонов.

Что бы возместить недостаток функциональности фреймворка, пользователи обычно делают вид что использование фреймворка стоит на первом месте. Потому что у них уже есть скрипты и стили которые покрывают все то чего нет во фреймворке. В принципе все это нормально, вопрос лишь в том как обеспечивается подобная «не фреймворковая функциональность» или расширения(мы уже знаем что ответственность за расширяемость так же лежит и на пользователе). Помимо всего прочего, расширения особенно выделяют необходимость в обеспечении основы безопасности кода – пространство имен (индивидуальные, характерные для фреймворка идентификаторы и префиксы в именах классов а так же собственное пространство имен для скриптов).

Новые и редко используемые практики становятся испытанием, что случается даже с лучшими из них. Всегда будет существовать потребность в чем ни будь новом и всегда будут типы документов или элементы которые используются часто. Это одна из причин разрастания кода. Их сложно контролировать если не управлять ими строго и организованно. Я мог бы долго рассуждать об этом дольше, но, эффективный прием состоит в создании отдельной области для нового и экспериментального кода и редких элементов, или даже и вовсе отказаться от отдельной части стилей и скриптов. Разработчики фреймворка должны ожидать подобного и давать рекомендациями, а пользователи должны применять собственные руководства если некоторые вопросы не были рассмотрены ранее. Документация к новому коду позволяет лучше отслеживать и принимать решение о том стоит ли оставить (или отделить) код или удалить его.

Мы успешно реализовали этот подход на HTML/CSS фреймворке Go от Google – не путать с языком программирования, который был разработан двумя годами позже. Go поставляется с «дополнительной» библиотекой Go X, которая содержит элементы которые лишь изредка были использованы нами. Это позволяет поддерживать небольшой размер ядра - 4,250 байт, включая лого Google – но предлагается использование дополнительные, распространенные элементы. Специфический код , созданный для сторонней разметки должен поддерживаться всеми скриптами и стилями проекта.

Что бы сделать фреймворк более расширяемым:

*Используйте пространства имен.
*Определите как будет осуществляться управление кодом не входящим в фреймворк.
*Регулярно просматривайте новый и редко используемый код, что бы выделить его в отдельную часть или удалить (это так же относится к пользователям фрймворка).

Заметьте пожалуйста, что несмотря на весь мой опыт и убеждения, я высказываю эти правила как предложение, хотя мне хотелось бы сказать «должны», «должны», «должны». В нашей веб разработке мы чаще придерживаемся догм, и используем именно это слово.
Еще одна вещь перед тем как двигаться дальше: отметьте что независимо от качества фреймворка, цель использования фреймворка всегда определяется его владельцами и разработчиками. Фреймворк можно сравнить с машиной: хорошая машина должна быть: ,безопасной, легкой в управлении  и экономичной. Хороший фреймворк так же одолжен быть специализированным, практичным и расширяемым. Мы смотрим на водителя, что бы понять пункт назначения его машины, так же мы смотрим на разработчика, что бы понять назначение фреймворка, который он использует. Мы можем «разбить фреймворк об стену» точно так же как машину, поэтому мы вводим разделение на профессионалов  и новичков. Подводя итог: фреймворк никогда не использует себя сам.





